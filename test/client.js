'use strict';

var assert = require('assert');

var helper = require('./helper');
var fromNative = require('../index');
var GearmanClient = fromNative.GearmanClient;


var client;
describe('client', function () {
  beforeEach(helper.startGearmanServer);
  afterEach(helper.stopGearmanServer);

  describe('doBackground', function() {
    beforeEach(function() {
      client = new GearmanClient();
      client.addServer('127.0.0.1', 4731);
      // client.setDebug(true);
    });
    afterEach(function(done) {
      client.stop(done);
    });

    it('should store the data on gearman', function (done) {
      var job = client.doBackground('queue', 'data', 'unique', function(err) {
        assert.ifError(err);

        assert.equal(job.returnCode(), fromNative.GEARMAN_SUCCESS);
        assert.equal(job.unique(), 'unique');

        helper.readAllJobs('queue', function(err, data) {
          assert.ifError(err);

          assert.equal(1, data.length);
          assert.equal(job.handle(), data[0].handle);
          assert.equal('data', data[0].workload);
          assert.equal('queue', data[0].func);
          assert.equal('unique', data[0].unique);
          assert.equal(4, Object.keys(data[0]).length);

          done();
        });
      });
    });

    it('should store the data on gearman with different data', function (done) {
      var job = client.doBackground('foo', 'blablabla', 'unique2', function(err) {
        assert.ifError(err);

        assert.equal(job.returnCode(), fromNative.GEARMAN_SUCCESS);
        assert.equal(job.unique(), 'unique2');

        helper.readAllJobs('foo', function(err, data) {
          assert.ifError(err);

          assert.equal(1, data.length);
          assert.equal(job.handle(), data[0].handle);
          assert.equal('blablabla', data[0].workload);
          assert.equal('foo', data[0].func);
          assert.equal(job.unique(), data[0].unique);
          assert.equal(4, Object.keys(data[0]).length);
          done();
        });
      });
    });

    it('should store the data on gearman without unique', function (done) {
      var job = client.doBackground('queue', 'blablabla', null, function(err) {
        assert.ifError(err);

        assert.equal(fromNative.GEARMAN_SUCCESS, job.returnCode());
        assert.equal(String, job.handle().constructor);

        helper.readAllJobs('queue', function(err, data) {
          assert.ifError(err);

          assert.equal(1, data.length);
          assert.equal(job.handle(), data[0].handle);
          assert.equal('blablabla', data[0].workload);
          assert.equal('queue', data[0].func);
          // generated by gearman server
          assert.equal(36, data[0].unique.length);
          assert.equal(4, Object.keys(data[0]).length);

          done();
        });
      });
    });

    it('should return error if gearman is unreachable', function (done) {
      helper.stopGearmanServer(function() {
        var job = client.doBackground('queue', 'data', 'unique', function(err) {
          assert.equal(fromNative.GEARMAN_COULD_NOT_CONNECT, job.returnCode());
          assert.equal('', job.handle());

          assert.equal(err.message, 'Gearman error');
          assert.equal(err.code, fromNative.GEARMAN_COULD_NOT_CONNECT);

          done();
        });
      });
    });

    it('should return error if gearman is unreachable on second', function (done) {
      var job1 = client.doBackground('queue', 'data', 'unique1', function(err) {
        assert.ifError(err);
        assert.equal(fromNative.GEARMAN_SUCCESS, job1.returnCode());

        helper.stopGearmanServer(function() {

          var job2 = client.doBackground('queue', 'data', 'unique2', function(err) {

            assert.equal(fromNative.GEARMAN_LOST_CONNECTION, job2.returnCode());
            assert.equal('', job2.handle());
            assert.equal(fromNative.GEARMAN_SUCCESS, job1.returnCode());

            assert.equal(err.message, 'Gearman error');
            assert.equal(err.code, fromNative.GEARMAN_LOST_CONNECTION);

            done();
          });
        });
      });
    });

    it('should allow queue more than one event', function (done) {
      var n = 100;
      var i = 0;
      function callback(err) {

        assert.ifError(err);
        i++;

        if (i === n) {
          done();
        }
      }

      for(var j = 0; j < n; j++) {
        var k = j;
        setTimeout(function() {
          client.doBackground('queue', 'data' + k, 'unique' + k, callback);
        }, 10);
      }
    });
  });

  describe('getStatus', function() {
    beforeEach(function() {
      client = new GearmanClient();
      client.addServer('127.0.0.1', 4731);
    });
    afterEach(function(done) {
      client.stop(done);
    });

    it('should return the result if the job exists', function (done) {
      var job = client.doBackground('queue', 'data', 'unique', function(err) {
        assert.ifError(err);

        client.getStatus(job.handle(), function(err, result) {
          assert.ifError(err);

          assert.equal(true, result.is_known);
          assert.equal(false, result.is_running);
          assert.equal(0, result.numerator);
          assert.equal(0, result.denominator);

          assert.equal(fromNative.GEARMAN_SUCCESS, result.returnCode);
          done();
        });
      });
    });

    it('should return the result if the job doesn\'t exist', function (done) {
      client.getStatus('unkown handle', function(err, result) {
        assert.ifError(err);

        assert.equal(false, result.is_known);
        assert.equal(false, result.is_running);
        assert.equal(0, result.numerator);
        assert.equal(0, result.denominator);

        assert.equal(fromNative.GEARMAN_SUCCESS, result.returnCode);
        done();
      });
    });

    it('should return an error if gearman is down', function (done) {
      helper.stopGearmanServer(function() {
        client.getStatus('unkown handle', function(err, result) {
          assert.equal(err.message, 'Gearman error');
          assert.equal(err.code, fromNative.GEARMAN_COULD_NOT_CONNECT);

          assert.equal(false, result.is_known);
          assert.equal(false, result.is_running);
          assert.equal(0, result.numerator);
          assert.equal(0, result.denominator);

          assert.equal(fromNative.GEARMAN_COULD_NOT_CONNECT, result.returnCode);
          done();
        });
      });
    });
  });
});
